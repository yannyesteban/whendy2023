package session1

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"sync"
)

type Machine struct {
	stores map[string]Store
}
type Manager struct {
	CookieName  string
	lock        sync.Mutex
	machine     Machine
	maxlifetime int64
}

var machines = make(map[string]Machine)

func Register(name string, machine Machine) {
	if machine == nil {
		panic("machine is nil")
	}
	if _, ok := machines[name]; ok {
		panic("machine yet exists")
	}

	machines[name] = machine
}

func Init() {
	Register("memory", Machine{})
}

type IStore interface {
	Set(key, value interface{}) error //set session value
	Get(key interface{}) interface{}  //get session value
	Delete(key interface{}) error     //delete session value
	SessionID() string                //back current sessionID
}

type IMachine interface {
	SessionInit(sid string) (IStore, error)
	SessionRead(sid string) (IStore, error)
	SessionDestroy(sid string) error
	SessionGC(maxlifetime int64)
}

type ManagerConfig struct {
	CookieName string

	StoreType   string
	Maxlifetime int64
}

func Create(config ManagerConfig) (*Manager, error) {
	//provideName string, cookieName string, maxLifeTime int64
	machine, ok := machines[config.StoreType]

	if !ok {
		return nil, fmt.Errorf("error was not created %v", config.StoreType)
	}

	return &Manager{CookieName: config.CookieName, maxlifetime: config.Maxlifetime, machine: machine}, nil
}

func (manager *Manager) sessionId() string {
	b := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return ""
	}
	return base64.URLEncoding.EncodeToString(b)
}

func (manager *Manager) Start(w http.ResponseWriter, req *http.Request) string {

	//fmt.Println(manager.CookieName)
	q, _ := req.Cookie("parada")
	println(q.Value)
	return "que"
}

type Store struct {
	data map[string]interface{}
}

func (s *Store) Set(key string, value interface{}) {
	s.data[key] = value
}

func (s *Store) Get(key string) interface{} {
	return s.data[key]
}

func (s *Store) Delete(key string) {
	delete(s.data, key)
}
